<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‰πùË∑ØÂúçÊ£ã</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            color: #ecf0f1;
        }
        .game-container {
            text-align: center;
            background: rgba(0,0,0,0.8);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
        }
        h1 {
            font-size: 2.5em;
            background: linear-gradient(45deg, #f39c12, #e67e22);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .status {
            font-size: 1.2em;
            margin: 20px 0;
            padding: 15px;
            background: rgba(52, 73, 94, 0.8);
            border-radius: 10px;
            border: 2px solid #3498db;
            line-height: 1.5;
        }
        #board {
            display: grid;
            grid-template-columns: repeat(9, 50px);
            grid-template-rows: repeat(9, 50px);
            gap: 4px;
            margin: 30px auto;
            padding: 20px;
            background: #1a1a1a;
            border-radius: 15px;
        }
        .cell {
            width: 50px;
            height: 50px;
            background: radial-gradient(circle at center, #8B4513 0%, #654321 70%);
            border: 3px solid #D2691E;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .cell:hover:not(.game-over .cell) { 
            transform: scale(1.05); 
            box-shadow: 0 5px 15px rgba(255,215,0,0.4); 
        }
        .cell.empty::before { 
            content: '+'; 
            color: rgba(255,255,255,0.3); 
            font-size: 24px; 
            font-weight: bold; 
        }
        .black {
            background: radial-gradient(circle at 30% 30%, #000 0%, #333 70%);
            box-shadow: inset 0 2px 8px rgba(0,0,0,0.8), 0 0 20px rgba(0,0,0,0.6);
        }
        .black::after { content: '‚óè'; font-size: 32px; color: #fff; text-shadow: 0 1px 2px #000; }
        .white {
            background: radial-gradient(circle at 30% 30%, #fff 0%, #ddd 70%);
            box-shadow: inset 0 2px 8px rgba(255,255,255,0.3), 0 0 20px rgba(255,255,255,0.4);
        }
        .white::after { content: '‚óè'; font-size: 32px; color: #333; text-shadow: 0 1px 2px #fff; }
        .captured { animation: capture 0.5s ease-out; }
        @keyframes capture {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.5; }
            100% { transform: scale(0); opacity: 0; }
        }
        .last-move { animation: pulse 1s infinite; }
        @keyframes pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 20px rgba(255,215,0,0.8); }
            50% { transform: scale(1.1); box-shadow: 0 0 30px rgba(255,215,0,1); }
        }
        button {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white; border: none; padding: 12px 24px;
            margin: 0 5px; border-radius: 25px; font-size: 16px;
            cursor: pointer; transition: all 0.3s;
        }
        button:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(52,152,219,0.6); }
        button:disabled { background: #95a5a6; cursor: not-allowed; }
        .pass-btn { background: linear-gradient(45deg, #f39c12, #e67e22) !important; font-weight: bold; }
        .pass-btn:hover:not(:disabled) { box-shadow: 0 8px 25px rgba(243,156,18,0.6) !important; }
        .score { display: flex; justify-content: space-around; margin-top: 20px; font-size: 1.3em; font-weight: bold; }
        .score div { padding: 10px 20px; border-radius: 10px; }
        .black-score { background: rgba(0,0,0,0.7); border: 2px solid #333; }
        .white-score { background: rgba(255,255,255,0.2); border: 2px solid #ddd; }
        .game-over { background: rgba(231,76,60,0.9) !important; border-color: #c0392b !important; font-size: 1.4em; animation: flash 1s infinite; }
        @keyframes flash { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .no-move { background: rgba(243, 156, 18, 0.8) !important; border-color: #f39c12 !important; }
        #passInfo { font-size: 1em; color: #f1c40f; font-weight: bold; margin-top: 10px; padding: 8px; background: rgba(0,0,0,0.5); border-radius: 8px; }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>üéØ ‰πùË∑ØÂúçÊ£ã </h1>
        <div class="status" id="status">üñ§ ÈªëÊ£ãÂÖàÊâãÔºåË´ãÈªûÊìäÊ£ãÁõ§‰∏ãÂ≠ê</div>
        <div id="board"></div>
        <div class="controls">
            <button onclick="game.undoMove()" id="undoBtn">ÊÇîÊ£ã</button>
            <button onclick="newGame()">Êñ∞Â±Ä</button>
            <button class="pass-btn" onclick="game.pass()" id="passBtn">ËÆìÂ≠ê</button>
            <button onclick="toggleAI()">AIÈñãÈóú</button>
        </div>
        <div class="score">
            <div class="black-score">ÈªëÊ£ã: <span id="blackScore">0</span></div>
            <div class="white-score">ÁôΩÊ£ã: <span id="whiteScore">0</span></div>
        </div>
        <div id="passInfo">ÈÄ£Á∫åËÆìÂ≠ê: <span id="passCount">0</span>/2</div>
    </div>

    <script>
        class NineBoardGo {
            constructor() {
                this.board = Array(9).fill().map(() => Array(9).fill(0));
                this.currentPlayer = 1;  // 1=Èªë, -1=ÁôΩ
                this.gameHistory = [];
                this.consecutivePasses = 0;
                this.aiEnabled = true;
                this.gameOver = false;
                this.initBoard();
                this.updateStatus();
            }

            initBoard() {
                const boardEl = document.getElementById('board');
                boardEl.innerHTML = '';
                for (let i = 0; i < 81; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell empty';
                    cell.dataset.row = Math.floor(i / 9);
                    cell.dataset.col = i % 9;
                    cell.addEventListener('click', (e) => this.handleClick(e));
                    boardEl.appendChild(cell);
                }
            }

            handleClick(e) {
                if (this.currentPlayer !== 1 || this.gameOver) return;
                const row = parseInt(e.currentTarget.dataset.row);
                const col = parseInt(e.currentTarget.dataset.col);
                if (this.isValidMove(row, col)) {
                    this.makeMove(row, col, 1);
                    this.gameHistory.push({row, col, player: 1});
                    this.consecutivePasses = 0;
                    document.getElementById('passCount').textContent = '0';
                    document.getElementById('passBtn').textContent = 'ËÆìÂ≠ê';
                    this.currentPlayer = -1;
                    this.updateStatus();
                    if (this.aiEnabled) setTimeout(() => this.aiMove(), 300);
                }
            }

            // ‚úÖ ÂÆåÁæéÁµÇÂ±ÄÂà§ÂÆö [web:14][web:27]
            pass() {
                this.consecutivePasses++;
                document.getElementById('passCount').textContent = this.consecutivePasses;
                document.getElementById('passBtn').textContent = `ËÆìÂ≠ê (${this.consecutivePasses}/2)`;
                
                // Ê¢ù‰ª∂1ÔºöÈõôÊñπÈÄ£Á∫å2Ê¨°pass
                if (this.consecutivePasses >= 2) {
                    this.endGame('‚úÖ ÈõôÊñπÈÄ£Á∫å2Ê¨°ËÆìÂ≠êÔºåÁµÇÂ±ÄÔºÅ');
                    return;
                }
                
                // Ê¢ù‰ª∂2ÔºöÈõôÊñπÈÉΩÁÑ°ÂêàÊ≥ïÊ£ãÊ≠•
                if (!this.hasValidMoves(this.currentPlayer) && !this.hasValidMoves(-this.currentPlayer)) {
                    this.endGame('‚úÖ ÈõôÊñπÂÖ®Á¶ÅËëóÈªûÔºåÁµÇÂ±ÄÔºÅ');
                    return;
                }
                
                this.currentPlayer = -this.currentPlayer;
                this.updateStatus();
                if (this.aiEnabled && this.currentPlayer === -1) {
                    setTimeout(() => this.aiMove(), 500);
                }
            }

            updateStatus() {
                if (this.gameOver) return;
                const statusEl = document.getElementById('status');
                const canMove = this.hasValidMoves(this.currentPlayer);
                const opponentCanMove = this.hasValidMoves(-this.currentPlayer);
                const playerName = this.currentPlayer === 1 ? 'üñ§ ÈªëÊ£ã' : '‚ö™ ÁôΩÊ£ã(AI)';
                
                if (canMove) {
                    statusEl.innerHTML = `${playerName} ÂõûÂêà - Ë´ãÈªûÊìä‰∏ãÂ≠ê`;
                    statusEl.className = 'status';
                    statusEl.style.background = this.currentPlayer === 1 ? 'rgba(0,0,0,0.8)' : 'rgba(255,255,255,0.2)';
                } else if (!opponentCanMove) {
                    statusEl.innerHTML = 'ÈõôÊñπÂÖ®ÁÑ°ÂêàÊ≥ïÊ£ãÊ≠• ‚Üí Ëá™ÂãïÁµÇÂ±Ä';
                    statusEl.className = 'status no-move';
                    setTimeout(() => this.endGame('‚úÖ ÈõôÊñπÂÖ®Á¶ÅËëóÈªûÔºåÁµÇÂ±ÄÔºÅ'), 1500);
                } else {
                    statusEl.innerHTML = `${playerName} ÁÑ°ÂêàÊ≥ïÊ£ãÊ≠• ‚Üí Ëá™ÂãïËÆìÂ≠ê`;
                    statusEl.className = 'status no-move';
                    setTimeout(() => this.pass(), 1500);
                }
            }

            hasValidMoves(player) {
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (this.isValidMoveForPlayer(r, c, player)) return true;
                    }
                }
                return false;
            }

            isValidMoveForPlayer(row, col, player) {
                if (this.board[row][col] !== 0) return false;
                const tempBoard = this.board.map(r => [...r]);
                tempBoard[row][col] = player;
                const opponent = -player;
                
                // Ê™¢Êü•ÊòØÂê¶ËÉΩÂêÉÂ≠ê
                let canCapture = false;
                const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
                for (let [dr, dc] of dirs) {
                    const nr = row + dr, nc = col + dc;
                    if (nr >= 0 && nr < 9 && nc >= 0 && nc < 9 && tempBoard[nr][nc] === opponent) {
                        if (!this.hasLiberties(tempBoard, nr, nc, opponent)) {
                            canCapture = true;
                            break;
                        }
                    }
                }
                if (canCapture) return true;
                
                // Ê™¢Êü•Ëá™Ë∫´Ê∞£
                return this.hasLiberties(tempBoard, row, col, player);
            }

            isValidMove(row, col) {
                return this.isValidMoveForPlayer(row, col, this.currentPlayer);
            }

            makeMove(row, col, player) {
                this.board[row][col] = player;
                const opponent = -player;
                const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
                
                // Ê™¢Êü•ÂêÉÂ≠ê
                for (let [dr, dc] of dirs) {
                    const r = row + dr, c = col + dc;
                    if (r >= 0 && r < 9 && c >= 0 && c < 9 && this.board[r][c] === opponent) {
                        if (!this.hasLiberties(this.board, r, c, opponent)) {
                            this.removeGroup(r, c, opponent);
                        }
                    }
                }
                
                this.lastMove = {row, col};
                this.currentPlayer = -player;
                this.updateBoardDisplay();
                this.updateScores();
                this.updateStatus();
            }

            hasLiberties(board, row, col, player) {
                const visited = Array(9).fill().map(() => Array(9).fill(false));
                return this.dfsLiberties(board, row, col, player, visited);
            }

            dfsLiberties(board, row, col, player, visited) {
                if (row < 0 || row >= 9 || col < 0 || col >= 9 || 
                    visited[row][col] || board[row][col] !== player) return false;
                visited[row][col] = true;
                const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
                
                for (let [dr, dc] of dirs) {
                    const nr = row + dr, nc = col + dc;
                    if (nr >= 0 && nr < 9 && nc >= 0 && nc < 9 && board[nr][nc] === 0) return true;
                }
                for (let [dr, dc] of dirs) {
                    if (this.dfsLiberties(board, row + dr, col + dc, player, visited)) return true;
                }
                return false;
            }

            removeGroup(row, col, player) {
                const visited = Array(9).fill().map(() => Array(9).fill(false));
                this.dfsRemove(row, col, player, visited);
            }

            dfsRemove(row, col, player, visited) {
                if (row < 0 || row >= 9 || col < 0 || col >= 9 || 
                    visited[row][col] || this.board[row][col] !== player) return;
                visited[row][col] = true;
                const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (cell) cell.classList.add('captured');
                this.board[row][col] = 0;
                const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
                for (let [dr, dc] of dirs) {
                    this.dfsRemove(row + dr, col + dc, player, visited);
                }
                setTimeout(() => { if (cell) cell.classList.remove('captured'); }, 500);
            }

            // ‚úÖ Âü∫Á§éAIÊ£ãÂäõ
            aiMove() {
                if (this.currentPlayer !== -1 || !this.aiEnabled || this.gameOver) return;
                
                if (!this.hasValidMoves(-1)) {
                    setTimeout(() => this.pass(), 500);
                    return;
                }
                
                const moves = [];
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (this.isValidMove(r, c)) {
                            moves.push({row: r, col: c, score: this.evaluateMove(r, c)});
                        }
                    }
                }
                
                if (moves.length > 0) {
                    moves.sort((a, b) => b.score - a.score);
                    this.makeMove(moves[0].row, moves[0].col, -1);
                    this.gameHistory.push({row: moves[0].row, col: moves[0].col, player: -1});
                } else {
                    setTimeout(() => this.pass(), 500);
                }
                this.updateStatus();
            }

            evaluateMove(row, col) {
                let score = 0;
                
                // Êòü‰ΩçÂÑ™ÂÖà
                if ((row === 2 || row === 6) && (col === 2 || col === 6)) score += 10;
                if ((row === 0 || row === 8) && (col === 0 || col === 8)) score += 8;
                if (row === 0 || row === 8 || col === 0 || col === 8) score += 5;
                
                // Èù†ËøëÈªëÊ£ã
                const dirs = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]];
                for (let [dr, dc] of dirs) {
                    const nr = row + dr, nc = col + dc;
                    if (nr >= 0 && nr < 9 && nc >= 0 && nc < 9 && this.board[nr][nc] === 1) {
                        score += 3;
                    }
                }
                
                // ÈñãÊîæÁ©∫Èñì
                let emptyNeighbors = 0;
                for (let [dr, dc] of dirs) {
                    const nr = row + dr, nc = col + dc;
                    if (nr >= 0 && nr < 9 && nc >= 0 && nc < 9 && this.board[nr][nc] === 0) {
                        emptyNeighbors++;
                    }
                }
                score += emptyNeighbors * 1;
                
                return score;
            }

            // ‚úÖ Ê®ôÊ∫ñË®àÂàÜ [web:18]
            endGame(reason = '') {
                this.gameOver = true;
                document.getElementById('undoBtn').disabled = true;
                document.getElementById('passBtn').disabled = true;
                
                let blackTotal = 0, whiteTotal = 0;
                
                // Ê¥ªÊ£ã
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (this.board[r][c] === 1) blackTotal++;
                        else if (this.board[r][c] === -1) whiteTotal++;
                    }
                }
                
                // ÂúçÂú∞ (Ê¥™Ê∞¥Â°´ÂÖÖ)
                const visited = Array(9).fill().map(() => Array(9).fill(false));
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (this.board[r][c] === 0 && !visited[r][c]) {
                            const territory = this.calculateTerritory(r, c, visited);
                            if (territory.blackBorder >= territory.whiteBorder) {
                                blackTotal += territory.size;
                            } else {
                                whiteTotal += territory.size;
                            }
                        }
                    }
                }
                
                const winner = blackTotal >= 41 ? 'üñ§ ÈªëÊ£ãÂãù' : '‚ö™ ÁôΩÊ£ãÂãù';
                const margin = Math.abs(blackTotal - whiteTotal);
                
                document.getElementById('status').innerHTML = 
                    `${reason}<br>${winner}ÔºÅ<br>ÊúÄÁµÇÊØîÂàÜÔºöÈªëÊ£ã ${blackTotal} : ÁôΩÊ£ã ${whiteTotal}<br>(${margin}Â≠êÂ∑Æ)<br>‰πùË∑Ø81ÁõÆÔºå‚â•41Âãù [web:18]`;
                document.getElementById('status').className = 'status game-over';
            }

            calculateTerritory(r, c, visited) {
                const stack = [{r, c}];
                let size = 0;
                let blackBorder = 0, whiteBorder = 0;
                const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
                
                while (stack.length > 0) {
                    const {r: row, c: col} = stack.pop();
                    if (row < 0 || row >= 9 || col < 0 || col >= 9 || 
                        visited[row][col] || this.board[row][col] !== 0) continue;
                    
                    visited[row][col] = true;
                    size++;
                    
                    for (let [dr, dc] of dirs) {
                        const nr = row + dr, nc = col + dc;
                        if (nr >= 0 && nr < 9 && nc >= 0 && nc < 9) {
                            if (this.board[nr][nc] === 1) blackBorder++;
                            else if (this.board[nr][nc] === -1) whiteBorder++;
                        }
                    }
                    
                    for (let [dr, dc] of dirs) {
                        stack.push({r: row + dr, c: col + dc});
                    }
                }
                return {size, blackBorder, whiteBorder};
            }

            updateBoardDisplay() {
                document.querySelectorAll('.cell').forEach(cell => {
                    const r = parseInt(cell.dataset.row), c = parseInt(cell.dataset.col);
                    const player = this.board[r][c];
                    cell.className = 'cell';
                    if (player === 1) cell.classList.add('black');
                    else if (player === -1) cell.classList.add('white');
                    else cell.classList.add('empty');
                    if (this.lastMove && r === this.lastMove.row && c === this.lastMove.col) {
                        cell.classList.add('last-move');
                        setTimeout(() => cell.classList.remove('last-move'), 1000);
                    }
                });
            }

            updateScores() {
                let black = 0, white = 0;
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (this.board[r][c] === 1) black++;
                        if (this.board[r][c] === -1) white++;
                    }
                }
                document.getElementById('blackScore').textContent = black;
                document.getElementById('whiteScore').textContent = white;
            }

            undoMove() {
                if (this.gameHistory.length === 0 || this.gameOver) return;
                const last = this.gameHistory.pop();
                this.board[last.row][last.col] = 0;
                this.currentPlayer = last.player === 1 ? -1 : 1;
                this.consecutivePasses = 0;
                document.getElementById('passBtn').textContent = 'ËÆìÂ≠ê';
                this.gameOver = false;
                document.getElementById('undoBtn').disabled = false;
                document.getElementById('passBtn').disabled = false;
                this.updateBoardDisplay();
                this.updateScores();
                this.updateStatus();
            }
        }

        let game;
        function newGame() { 
            document.getElementById('passBtn').textContent = 'ËÆìÂ≠ê';
            game = new NineBoardGo(); 
        }
        function toggleAI() {
            if (!game) return;
            game.aiEnabled = !game.aiEnabled;
            document.querySelector('button:last-child').textContent = 
                game.aiEnabled ? 'AIÈñãÈóú (Èñã)' : 'AIÈñãÈóú (Èóú)';
        }
        window.onload = () => newGame();
    </script>
</body>
</html>

